---
title: "SQL databases and R"
output:
  html_document:
    theme: flatly
    toc: yes
    toc_float: yes
    font:family: Lato
  pdf_document:
    toc: yes
---

Learning Objectives:

- Access a database from *R*.
- Run SQL queries using `RSQLite` and `dplyr`.
- Describe the lazy behaviour of `dplyr` on data stored in a database outside of *R*.
- Prototype queries and retrieve all final results.
- Create complex queries across on of multiple databse tables.
- Create an SQLite database from existing `.csv` files.

# The `portal_mammals` database

We can explore the `surveys` data. First, we load in the `dbplry` and `RSQLite' package.

```{r}
library(dplyr)
library(dbplyr)
library(RSQLite)
```

Let's now download our file `portal_mammals.sqlite`. 

```{r}
dir.create("raw_data", showWarnings = FALSE)
download.file(url = "https://ndownloader.figshare.com/files/2292171",
              destfile = "raw_data/portal_mammals.sqlite", mode = "wb")
```

# Connecting to databases

We can point `R` to this database.

```{r}
mammals <- DBI::dbConnect(RSQLite::SQLite(), "raw_data/portal_mammals.sqlite")
```

This command uses two packages enable `dbplry` and `dplyr` communicate with the SQLite database. "DBI" is not something that we'll ever use directly as a user. It allows *R* to send commands to databses irrespetive of the database management system used. The `RSQLite` package allows *R* to interface with SQLite databases.

This command does not load the data into the *R* session (unlike the `read_csv()` function). Instead, it merely instructs *R* tp connect to the SQLite database contained in the `portal_mammals.sqlite` file.

Let's now take a closer look at the `mammals` database we've connected toc

```{r}
src_dbi(mammals)
```

Just like a spreadsheet with multiple worksheets, a SQLite database can contain multiple tables. In this case, three of them are listed in the `tbls` ros in the output above:

- plots
- species
- surveys
  
Now that we know we can connect to the databse, let's explore how to get the data from its tables in *R*.

## Querying the database with the `SQL` syntax

To connect to tables within a database, we can use the `tbl()` function from `dplyr`. This function can be used to send SQL queries to the database. To demonstrate this, let's select the columns `year`, `species_id`, and `plot_id` from the surveys table.

```{r}
tbl(mammals, sql("SELECT year, species_id, plot_id FROM surveys"))
```

## Querying the database with the `dplyr` syntax

One of the strengths of `dplyr` is that the same operations can be done using `dplyr`'s verbs instead of writing `SQL`. First, we select the table on which to do the operations by creating the surveys object, and then we use the same standard `dplyr` syntax as if it were a data frame.

```{r}
surveys <- tbl(mammals, "surveys")
surveys %>%
  select(year, species_id, plot_id)
```

In this case, the `surveys` object behaves like a data frame. Several functions that can be used with data frames can also be used on tables from a database. For instance, the `head()` function can be used to check the first 10 rows of the table.

```{r}
head(surveys, 10)
```

This output looks just like a regular dataframe. The table has 9 columns, and the `head()` function shows us the furst 10 rows. Note that the columns `plot_type`, `taxa`, `genus`, and `species` are missing. These are now located in the tables `plots` and `species` which we will join together in a moment.

However, some functions don't work quite as expected. For instance, let's check how many rows are in total using `nrow()`

```{r}
nrow(surveys)
```

That's strange - *R* doesn't know how many rows the `surveys` table contains, it returns `NA` instead. If we have a look at the first output from the `head()` function, we notice that the first line includes '???`, indicating that the number of rows wasn't known. 

The reason for this behaviour highlights a key difference between using `dplyr` on datasets in memory (e.g. loaded into your *R* session via `read_csv()`), and also provided by a database. To understand it, we take a closer look at how `dplyr` communicates with our `SQLite` database.

## SQL Translation

Relational databases typically use a special-purpose language, `Strcutured Query Language (SQL), to manage and query data.

For example, the following SQL query returns the first 10 rows from the surveys table

` 
SELECT 
FROM 'surveys' 
LIMIT 10
`

Behind the scenes, `dplyr`:

- Translates the *R* code in *SQL*.
- Submits it to the database.
- Tranlates the database's response into an *R* data frame.

To see exactly what's going on, we can use `dplyr`'s `show_query()` function to show which `SQL` commands are actually sent to the database:

```{r}
show_query(head(surveys, 10))
```

The output shows the actual SQL query sent to the database, it matches our manually constructed `SELECT` statement above. 

Instad of having to formulate the SQL query ourselves, and having to mentally switch back and forth between *R* and *SQL* syntax, we can delegate this translation to `dplyr`. The best bit is, we don't even have to know SQL to interact with a database via `dplyr`.

`dplyr`, in turn, doesn't do the real work of subsetting the table, either. Instead, it sends the query to the database, waits for its response and returns it to us.

That way, *R* never gets to see the full `surveys` table - and that's why it could not tell us how many rows it contains. However, this allows us to work with large datasets - even too large to fit into our computer's memory.

`dplyr` can translate many different query types into SQL, allowing us to e.g. `select()` specific columns, `filter()` rows, or join tables.

To see this in action, let's compose a few queries with `dplyr`

## Simple Database Queries

First, let's request rows of the surveys table in which `weight` < 5, and keep only the `species_id`, `sex`, and `weight` columns. 

```{r}
surveys %>%
  filter(weight < 5) %>%
  select(species_id, sex, weight)
```

Executing this command will return a table with 10 rows and the required `species_id`, `sex`, and `weight`. Perfect.

However, there appears to be only 10 rows. Why did *R* only retrieve 10 rows?

# Laziness

